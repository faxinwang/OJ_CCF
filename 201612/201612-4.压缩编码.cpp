/*
试题编号：	201612-4
试题名称：	压缩编码
时间限制：	3.0s
内存限制：	256.0MB
问题描述：	
　　给定一段文字，已知单词a1, a2, …, an出现的频率分别t1, t2, …, tn。可以用01串给这些单词编码，即将每个单词与一个01串对应，
    使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。
　　使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为：
　　L=a1的编码长度×t1+a2的编码长度×t2+…+ an的编码长度×tn。
　　定义一个前缀编码为字典序编码，指对于1 ≤ i < n，ai的编码（对应的01串）的字典序在ai+1编码之前，即a1, a2, …, an的编码是
    按字典序升序排列的。例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2, 5，则
    一种可行的编码方案是A:000, B:001, C:01, D:10, E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长
    度L为3×1+3×3+2×4+2×2+2×5=34。
　　在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，
    但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。
　　在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。
　　请找出一个字典序编码，使得文字经过编码后的长度L最小。在输出时，你只需要输出最小的长度L，而不需要输出具体的方案。在上面的例子中，
    最小的长度L为34。

输入格式
　　输入的第一行包含一个整数n，表示单词的数量。
　　第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an出现的频率，即t1, t2, …, tn。请注意a1, a2, …, an具体是什么单词并不影响本题
    的解，所以没有输入a1, a2, …, an。

输出格式
　　输出一个整数，表示文字经过编码后的长度L的最小值。

样例输入
5
1 3 4 2 5

样例输出
34

样例说明
　　这个样例就是问题描述中的例子。如果你得到了35，说明你算得有问题，请自行检查自己的算法而不要怀疑是样例输出写错了。

评测用例规模与约定
　　对于30%的评测用例，1 ≤ n ≤ 10，1 ≤ ti ≤ 20；
　　对于60%的评测用例，1 ≤ n ≤ 100，1 ≤ ti ≤ 100；
　　对于100%的评测用例，1 ≤ n ≤ 1000，1 ≤ ti ≤ 10000。


解题思路:
先说一下取石子游戏: n堆石子排成一行, 每次可以将相邻(任意)两堆石子合并成一堆石子, 每次合并产生的耗费(收益)是两堆石子的数量之和, 
求将这n堆石子合并成一堆石子的总耗费(收益)最小(最大)是多少?
题目中的相邻与任意, 收益与耗费, 最小还是最大, 应该根据具体题目而定.

对于[相邻, 耗费, 最小]的取石子模型, 其解法为:
设dp[i][j] 表示合并从第i堆到第j堆石子所需要的总耗费, 一堆石子合并不产生耗费,也就是dp[i][i] = 0,
v[i]为第i堆石子中石子的数量, sum[i]为前i堆石子的数量之和
则当i+1=j时, dp[i][j] = v[i] + v[j], 
当i+2=j时, dp[i][j] = min{dp[i][i+1]+dp[j][j], dp[i][i] + dp[j-1][j] }
当i+3=j时, dp[i][j] = min{ ... },
总的来说, 可以得到DP公式: dp[i][j]=min(dp[i][k]+dp[k][j]) + sum[i] - sum[j-1] (i<= k < j)

本题的情况与[相邻, 耗费, 最小]的取石子模型是一样的.
而赫夫曼树与[任意, 耗费, 最小]的取石子模型是一样的.

如果一下想不过来的话, 这里可以对比一下赫夫曼树与[任意, 耗费, 最小]的取石子模型:
1. n对石子排成一排(n个相互独立的结点)
2. 每次取石子数量最小的两堆石子合并成一堆石子(每次取数值最小的两个结点合并成一颗树,树的根结点为这两个结点的数值之和)
3. 不断重复第2步的过程, 直到只剩下一堆石子(一颗树)

赫夫曼树中, 数值越小的结点, 越早被选中并与其他结点结合, 因此在树中的深度也越大, 其对应的编码长度也越长; 数值越大的结点,
与其他结点结合得越晚, 因此在树中的深度也越小, 其对应的编码长度也就越短. 结点中的数值表示相应符号出现的频率, 因此赫夫曼编码中,
编码长度很大符号, 其出现的频率很低, 出现频率很大的符号, 其编码长度很短, 因此可以有效压缩总体的编码长度.

根据题目中的编码方案, 可以恢复出这课树的结构(非页结点用O表示,编码规则为左0右1):
A、B、C、D、E出现的频率分别为1, 3, 4, 2, 5

A:000, B:001, C:01, D:10, E:11
                          O
                         / \ 
                       /     \
                      O       O
                    /  \    /   \
                   O    C  D     E
                  / \
                 A   B
                       图(1)
如果采用赫夫曼的建树规则, 则树的形状如下:
A:000  D:001  B:01   C:10  E:11
                         O
                      /    \   
                    O       O
                   / \     / \
                  O   B   C   E
                 / \   
                A   D
                     图(2)
使用赫夫曼树得到的编码不符合题目中 a1,a2,...,an的编码顺序必须是按字典序升序的规定
如果要满足这个规定, 那么a1,a2,...,an在树中的顺序应该是a1,在最左边, a2在次左边, ..., an在最右边,
就像上面的图(1)中那样.

其建树过程与[相邻, 耗费, 最小]的取石子模型如出一辙, 求解方法在上面已经给出了.
*/     


#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn = 1e3+5;
const int INF = 1e8;

int sum[maxn]={0};
int d[maxn][maxn];

int dp(int L, int R)
{
    if(d[L][R] < INF) return d[L][R];
    if(L == R) return 0;
    for(int k=L; k<R; ++k)
    {
        d[L][R] = min( d[L][R],  dp(L,k) + dp(k+1,R) + sum[R] - sum[L-1] );
    }

    return d[L][R];
}

int main()
{
    #ifdef WFX
    freopen("in.txt","r",stdin);
    #endif
    int n,v;
    scanf("%d", &n);
    for(int i=1; i<=n ; ++i)
    {
        scanf("%d",&v);
        sum[i] = sum[i-1] + v;
    }

    for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j) d[i][j] = INF;

    cout<< dp(1,n) <<endl;

    return 0;
}