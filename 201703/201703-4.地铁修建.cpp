/*
试题编号：	201703-4
试题名称：	地铁修建
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。
　　地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，
    没有隧道两端连接着同一个交通枢纽。
　　现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。
    所有公司同时开始施工。作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地
    铁最少需要多少天。
输入格式
　　输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。
　　第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。
输出格式
　　输出一个整数，修建整条地铁线路最少需要的天数。
样例输入
6 6
1 2 4
2 3 4
3 6 7
1 4 2
4 5 5
5 6 6
样例输出
6
样例说明
　　可以修建的线路有两种。
　　第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完；
　　第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。
　　第二种方案所用的天数更少。
评测用例规模与约定
　　对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 20；
　　对于40%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000；
　　对于60%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000，1 ≤ c ≤ 1000；
　　对于80%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000；
　　对于100%的评测用例，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。

　　所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。

解题思路:
刚开始想到的是DFS+二分查找, 但是只拿到了40分.
后来看了一下别人博客才发现竟然有这么简单的思路, 原理为:
1. 将所有的边按照权值从小到大排序.
2. 一开始将所有的顶点看成是相互孤立的, 图中只有点,没有边.
3. 然后逐渐加入权值最小的边, 每次加入一条边之后, 判断1与N结点是否连通
   如果加入某条边后, 1与N变成了连通, 那么加入的这条边的权值就是答案.
4. 可以用并查集快速加边和判断两个结点的连通性

*/


#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 1e5+5;
const int maxm = 2e5+5;

struct Edge
{
    int u, v , w;
    bool operator<(const Edge& e)const{ return  w < e.w; }
}edg[maxm];

int p[maxn]={0};

int Find(int x){ return p[x]==0||p[x]==x ?  x  : p[x] = Find(p[x]); }

void Union(int a, int b)
{  
    int pa = Find(a), pb = Find(b);
    if(pa != pb) p[pa] = pb;
}

int main()
{
    #ifdef WFX
    freopen("in.txt","r",stdin);
    #endif
    int N,M;
    int u, v, w;
    scanf("%d%d",&N,&M);
    for(int i=0; i<M; ++i) scanf("%d%d%d", &edg[i].u, &edg[i].v, &edg[i].w);
    sort(edg, edg+M);
    
    for(int i=0; i<M; ++i)
    {
        Union(edg[i].u, edg[i].v); //加入一条边
        if(Find(1) == Find(N))
        {
            printf("%d\n", edg[i].w);
            break;
        }
    }

    return 0;
}